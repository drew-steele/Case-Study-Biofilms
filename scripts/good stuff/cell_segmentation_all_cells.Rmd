---
title: "cell_segmentation_all_cells"
author: "Drew"
date: "2024-02-06"
output: html_document
---

```{r}
library(EBImage)
```

```{r}
img <- readImage("data/trial2.tif")
```

```{r}
display(img, method="browser")
```

cropping 

```{r}
imgCr = img[512:1024, 1:512, 1:3]

imgR <- getFrame(imgCr, 1)
imgG <- getFrame(imgCr, 2)

par(mfrow = c(1,3))
plot(imgR)
plot(imgG)
plot(imgCr)

```

offset subtraction 

```{r}

par(mfrow = c(1,2))
plot(imgG[436:463, 325:360]*4)
plot(imgR[436:463, 325:360]*4)

osR=mean(imgR[436:463, 325:360])
osG=mean(imgG[436:463, 325:360])

imgRo <- imgR - osR
imgGo <- imgG - osG

par(mfrow = c(2,2))
plot(imgR)
plot(imgRo)
plot(imgG)
plot(imgGo)
```

edge detection - 2

```{r}

k = matrix(-1, nrow = 3, ncol = 3)
k[2, 2] = 8
k

imgRe2 <- EBImage::filter2(gblur(imgRo,sigma=1.5),k)
par(mfrow = c(1,2))
plot(imgCr)
plot(normalize(imgRe2))

imgGe2 <- EBImage::filter2(gblur(imgGo,sigma=1.5),k)
par(mfrow = c(1,2))
plot(imgCr)
plot(normalize(imgGe2))

```

adaptive thresholding - Edge2 image 

```{r}

imgRat1e2 <- thresh(imgRe2, w=5, h=5, offset=0.1)
imgRat2e2 <- thresh(imgRe2, w=5, h=5, offset=0.05)
imgRat3e2 <- thresh(imgRe2, w=5, h=5, offset=0.025)

par(mfrow = c(2,2))
plot(imgRat1e2)
plot(imgRat2e2)
plot(imgRat3e2)
plot(imgCr * 2)


imgGat1e2 <- thresh(imgGe2, w=5, h=5, offset=0.1)
imgGat2e2 <- thresh(imgGe2, w=5, h=5, offset=0.05)
imgGat3e2 <- thresh(imgGe2, w=5, h=5, offset=0.025)

par(mfrow = c(2,2))
plot(imgGat1e2)
plot(imgGat2e2)
plot(imgGat3e2)
plot(imgCr * 2)
```

reviewing thresholding methods

```{r}

par(mfrow = c(2,2))
plot(imgRat3e2)
plot(imgRat3e)
plot(imgRat3)
plot(imgCr * 2)

par(mfrow = c(2,2))
plot(imgGat3e2)
plot(imgGat3e)
plot(imgGat3)
plot(imgCr * 2)

```

watershed

```{r}
nmaske2 <- watershed(distmap(imgGat3e2), tolerance = 1, ext = 1)

par(mfrow = c(1,2))
plot(colorLabels(nmaske2))
plot(imgCr * 2)

# nmask

#display(colorLabels(nmaske2), all=TRUE)
```

```{r}
all_cells <- as.data.frame(computeFeatures.moment(nmaske2))
write.csv(all_cells, file = "results/all_cells.csv")
red_cells <- read.csv("results/redcells.csv")
all_cells <- read.csv("results/all_cells.csv")
```


```{r}
plotontop <- function(img, cells, red) {
  
  x <- flip(img *2)
  
  par(mar = c(0, 0, 0, 0))  # Set margins to zero
  plot(1, type = "n", xlab = "", ylab = "", xlim = c(0, 1), ylim = c(0, 1), asp =1)
  
  rasterImage(x, 0, 0, 1, dim(x)[2]/dim(x)[1])
  points(x = cells$m.cx / dim(x)[1], y = cells$m.cy / dim(x)[1], col = "red", pch = 1)
  points(x = red$m.cx / dim(x)[1], y = red$m.cy / dim(x)[1], col = "blue", pch = 1)
  
}
```

plotting red and green extracted points on image 

```{r}
par(mfrow = c(1,1))

plotontop(imgCr, all_cells, red_cells)
```

### now goign to calc neareast neighbour, if neigbour is within certain distance will delete the poitn from all cells and only keep the red cell 

```{r}
library(spatstat)
```

manipulating data

```{r}
red_c <- red_cells[,2:3]
red_c[,3] <- "dead"

all_c <- all_cells[,2:3]
all_c[,3] <- "all"
 
cells <- rbind(red_c, all_c)
colnames(cells) <- c("x", "y", "condition")
```

creating spatstat point pattern object 

```{r}
pat <- ppp(cells[,1], cells[,2], c(0,513), c(0,513)) # creating point pattaern object 
marks(pat) <- cells[,3] # adding infor on live dead - any extra info refered to as mark in spatstat
anyDuplicated(pat) # checking for duplicated poitns 
```

calculating nearest neighbour and selecting those closet together 

```{r}

NN_which <- nnwhich(cells)
NN_dist <- nndist(cells)

NN_all <- as.data.frame(cbind(NN_which, NN_dist))

min(NN_all$NN_dist)
max(NN_all$NN_dist)
hist(NN_all$NN_dist)

dups <- NN_all[NN_all$NN_dist < 1 ,]

```



```{r}
x <- as.numeric(pat$x)
y <- as.numeric(pat$y)
m <- pat$marks

test <- as.data.frame(cbind(x, y))
test <- cbind(test, m) 
str(test)
```

```{r}
dups_cells <- cbind(test, NN_all)

livingcells <- as.data.frame(dups_cells[dups_cells$m == "all" & dups_cells$NN_dist > 2 ,])

str(livingcells)

```


```{r}
plotontop2 <- function(img, green, red) {
  
  y <- flip(img *2)
  
  par(mar = c(0, 0, 0, 0))  # Set margins to zero
  plot(1, type = "n", xlab = "", ylab = "", xlim = c(0, 1), ylim = c(0, 1), asp =1)
  
  rasterImage(y, 0, 0, 1, dim(y)[2]/dim(y)[1])
  points(x = green$x / dim(y)[1], y = green$y / dim(y)[1], col = "blue", pch = 1)
  points(x = red$m.cx / dim(y)[1], y = red$m.cy / dim(y)[1], col = "red", pch = 1)
  
}
```


```{r}
plotontop2(imgCr, livingcells, red_cells)
```

